import "metric_functions.eol";
import "thresholds.eol";

//libraries
import "library/artifact.eol";
//import "library/class.eol";
import "library/classifier.eol";
import "library/component.eol";
import "library/element.eol";
import "library/interaction.eol";
import "library/interactionFragment.eol";
import "library/interactionOperand.eol";
import "library/interface.eol";
import "library/lifeline.eol";
import "library/manifestation.eol";
import "library/message.eol";
import "library/node.eol";
import "library/operation.eol";
import "library/package.eol";

/*********************************************************************************************
 *																							 *
 *	 								Pipe and Filter 										 *
 *							Antipattern Detection and Validation					 		 *
 *										reviewed											 *
 *********************************************************************************************/

/*context Operation {
	critique PaF {
		check: 
			not (self.F_probExec() and 
				self.F_resDemand(th_maxResDemand()) and
					(not self.F_T(th_SthReq()) or not self.F_maxHwUtil(th_maxHwUtil()) ))	
		message : "PaF <Operation> " + self.name
		fix {
			title : "Move it to a new Component deployed to a new Node"
			do {
				self.moveToNewOwnerDeployedOnNewNode(); 
			}
		}
		fix{
			title : "Move it to a new Component deployed to the less used neighbour Node"
			do{
				self.moveToNewOwnerDeployedOnNearLessUsedNode();
			}
		}
		fix{
			title : "Redeploy its owning Component "+self.class.name+" to the less used neighbour Node"
			do{
				self.redeployOnNearLessUsedNode();
			}
		}
		fix{
			title : "Change its owning Component from "+self.class.name+" to the one with the lowest demand"
			do{
				self.moveToLessCriticalOwner();
			}
		}
		fix{
			title: "Decomposition"
			do{
				self.decomposition();
			}
		}
	}
}*/


/*********************************************************************************************
 *																							 *
 *	 							Concurrent Processing Systems 								 *
 *							Antipattern Detection and Validation			     			 *
 *									 reviewwed												 *
 *********************************************************************************************/
 
/*context Node {
	critique CPS {
		check: 
			not ( self.F_maxQL(th_maxQL()) and self.F_maxHwUtil(th_maxHwUtil()) )
		message : "CPS <" + self.type.name + "> " + self.name
		fix {
			title : "Move it to a new Component deployed to a new Node"
			
			do {
				self.moveToNewComponentDeployedOnNewNode(); 
			}
		}
		fix{
			title : "Move it to a new Component deployed to the less used neighbour Node"
			do{
				self.moveToNewComponentDeployedOnNearLessUsedNode();
			}
		}
		fix{
			title : "Redeploy its owning Component "+self.name+" to the less used neighbour Node"
			do{
				self.redeployOnNearLessUsedNode();
			}
		}
		fix{
			title : "Change its owning Component from "+self.name+" to the one with the lowest demand"
			do{
				self.moveToLessCriticalComponent();
			}
		}
	}
}*/

/*********************************************************************************************
 *																							 *
 *	 								Extensive Processing  									 *
 *							Antipattern Detection and Validation							 *
 *										reviewed											 *
 *********************************************************************************************/
/* context Component {
 	critique ExtensiveProcessingAP{
 		check:
 			not (self.F_resDemand(th_maxResDemand(), th_minResDemand()) and 
 					self.F_probExec() and 
 						( self.F_maxHwUtil(th_maxHwUtil())) or self.F_RT(th_SrtReq()) )
 		message : "EP <" + self.type.name + "> " + self.name
 		fix {
			title : "Move it to a new Component deployed to a new Node"
			
			do {
				self.moveToNewComponentDeployedOnNewNode(); 
			}
		}
		fix{
			title : "Move it to a new Component deployed to the less used neighbour Node"
			do{
				self.moveToNewComponentDeployedOnNearLessUsedNode();
			}
		}
		fix{
			title : "Redeploy its owning Component "+self.name+" to the less used neighbour Node"
			do{
				self.redeployOnNearLessUsedNode();
			}
		}
		fix{
			title : "Change its owning Component from "+self.name+" to the one with the lowest demand"
			do{
				self.moveToLessCriticalComponent();
			}
		}
 	}
}*/

/*********************************************************************************************
 *																							 *
 *								Blob Controller & Container									 *
 *							Antipattern Detection and Validation							 *
 *										reviewed 											 *
 *********************************************************************************************/


context Component {
	critique Blob_Controller {
		check {
			if( self.F_numClientConnects(th_maxConnects()) and self.F_numMsgsOut(th_maxMsgs()) and 
				( self.F_maxHwUtil(th_maxHwUtil()) or self.F_maxNetUtil(th_maxNetUtil()) )
			)
				return false;
			return true;
		}
		message : "Blob Controller <" + self.type.name + "> " + self.name
		fix{
			title : "Redeploy its owning Component "+self.name+" to the less used neighbour Node"
			do{
				self.redeployOnNearLessUsedNode();
			}
		}
		fix {
			title: "Reduce Client Connects <" + self.name + ">"
			do {
				self.reduceNumberOfClientConnects(th_maxConnects());
			}
		}
	}
}

context Component {
	critique Blob_dataContainer {
		check {
			if( self.F_numSupplierConnects(th_maxConnects()) and self.F_numMsgsIn(th_maxMsgs()).println() and 
				( self.F_maxHwUtil(th_maxHwUtil()) or self.F_maxNetUtil(th_maxNetUtil()) )
			)
				return false;
			return true;
		}
		message : "Blob Container <" + self.type.name + "> " + self.name
		fix{
			title : "Redeploy its owning Component "+self.name+" to the less used neighbour Node"
			do{
				self.redeployOnNearLessUsedNode();
			}
		}
		fix {
			title: "Reduce Supplier Connects of <"+ self.name +">"
			do{
				self.reduceNumberOfSupplierConnects(th_maxConnects());
			}
		}
	}
}


/*********************************************************************************************
 *																							 *
 *	 								Empty Semi Truck										 *
 *							Antipattern Detection and Validation							 *
 *										reviewed											 *
 *********************************************************************************************/
 /*context Component {
 	critique EmptySemiTruck{
 		check{
 			if(self.F_numRemMsgs(th_maxRemMsgs()) and 
 				(self.F_maxNetUtil(th_minNetUtil()) or self.F_numRemInst(th_maxRemInst()))
 			)
 				return false;
 			return true;
 		}
 		message : "EST <" + self.type.name + "> " + self.name
 		fix {
			title : "Apply Session Facade Pattern"
			do {
				self.applySessionFacade();
			}
		}
 	}
}*/

/*********************************************************************************************
 *																							 *
 *	 								Tower of Babel											 *
 *							Antipattern Detection and Validation							 *
 *									reviewed												 *
 *********************************************************************************************/
 /*context Component {
 	critique TowerOfBabel{
 		check{
 			if(self.F_numExF(th_maxExF()) and self.F_maxHwUtil(th_maxHwUtil()))
 				return false;
 			return true;
 		}
 		message : "ToB <" + self.type.name + "> " + self.name
 		fix {
			title : "Apply the most used format"
			do {
				self.applyStandardFormat();
			}
		}
		fix{
			title : "Redeploy its owning Component "+self.name+" to the less used neighbour Node"
			do{
				self.redeployOnNearLessUsedNode();
			}
		}
 	}
}*/

/*********************************************************************************************
 *																							 *
 *	 						    Circuitous  Treasure Hunt									 *
 *							Antipattern Detection and Validation							 *
 *																							 *
 *********************************************************************************************/
 
/*********************************************************************************************
 *																							 *
 *	 						    		One Line Bridge										 *
 *							Antipattern Detection and Validation							 *
 *																							 *
 *********************************************************************************************/
 
/*********************************************************************************************
 *																							 *
 *					    		Excessive Dynamic Allocation								 *
 *							Antipattern Detection and Validation							 *
 *																							 *
 *********************************************************************************************/
 